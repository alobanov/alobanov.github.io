I"z2<h1 id="перевод-статьи-била-сандерса-о-реализации-классического-мета-паттерна-mvc-на-smalltalk-80">Перевод статьи Била Сандерса о реализации классического мета паттерна MVC на Smalltalk-80. </h1>

<p>Это мой вольный перевод статьи Била Сандерса о реализации классического мета паттерна <strong>MVC</strong> на <strong>Smalltalk-80</strong>. Так как это мой первый опыт, строго не судите и в комментариях желательно оставлять какие либо замечания по тексту. Переводил не дословно, немного из русскоязычных источников накопал (:grin: и каюсь, перевёл не всё).</p>

<hr />

<h1 id="предисловие">Предисловие</h1>

<p>Это не введение в модель MVC, а обзор его осуществления на <a href="https://ru.wikipedia.org/wiki/Smalltalk">Smalltalk-80</a> для понимания первоначальных намерений и функций триады. Классическая MVC поможет лучше понять последующее развитие паттернов, которые появились позже. Посмотрим, как простое MVC приложение работает в <strong>Smalltalk-80</strong> и изучим как оно может быть реализовано на языке <strong>ActionScript</strong>.</p>

<blockquote>
  <p><strong>Model-view-controller</strong> (MVC, «Модель-представление-поведение», «Модель-представление-контроллер») — архитектура программного обеспечения, в которой <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85">модель данных</a> приложения, <a href="https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81_%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8F">пользовательский интерфейс</a> и управляющая логика разделены на три отдельных компонента, так, что модификация одного из компонентов оказывает минимальное воздействие на другие компоненты.</p>
</blockquote>

<h3 id="реализация-model-view-controller-в-smalltalk-80">Реализация Model-View-Controller в Smalltalk-80.</h3>
<p>Модель MVC облегчает разделение ответственности при разработке интерактивных графических приложений. Логика и состояние приложения, как пользователи взаимодействуют с приложением, и как состояние приложения представляется пользователю по средствам отдельных элементов триады MVC. <strong>Smalltalk-80</strong> использует метафору MVC, что обеспечивает встроенную поддержку для интерактивной разработки приложений.</p>

<p>Идея заключалась в том, чтобы обеспечить набор встроенных компонентов <a href="https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81_%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8F">пользовательского интерфейса</a>, таких как кнопки, меню и списки, которые могут быть подключены к GUI приложения. Для эффективного использования этих встроенных элементов интерфейса, реализация должна была быть построена в соответствии с <em>MVC</em>. Давайте посмотрим на концептуальную диаграмму приложения <strong>Smalltalk-80</strong>.
<br /></p>

<hr />

<p><img src="/images/schemamvc.jpeg" alt="" /></p>

<h4 id="point_upдиаграмма-mvc-в-smalltalk-80-krasner--pope">:point_up:Диаграмма MVC в Smalltalk-80 (Krasner &amp; Pope)</h4>

<hr />

<p>Диаграмма MVC в <strong>Smalltalk-80</strong> (<a href="http://www.math.rsu.ru/smalltalk/gui/">Krasner &amp; Pope</a>) Все объекты в Smalltalk общаться друг с другом при помощи сообщений, которые является способом вызова методов объекта. На первый взгляд, диаграмма MVC кажется немного странной. Model-View и Controller-Model имеют зависимости направленные в обе стороны. Вторым интересным аспектом было то, что пользовательский ввод идет непосредственно через контроллер. Это является существенным изменением, как правило мы ожидаем от пользователя взаимодействия с элементами интерфейса в представлении (View), а не в корнтроллере.</p>

<p>В <strong>Smalltalk-80</strong>, все данные с устройства ввода подаются непосредственно в контроллер. Давайте кратко рассмотрим, как MVC поддерживается в <strong>Smalltalk-80</strong>.</p>

<hr />

<h1 id="mvc-классы-в-smalltalk-80">MVC классы в Smalltalk-80.</h1>

<p>Есть три абстрактных класса называемые Модель, Вид и Контроллер. Все конкретные реализации модели, вида и контроллера должны иметь подклассы этих абстрактных суперклассов. Давайте взглянем на классы (это сокращенное описание — см. <a href="http://www.math.rsu.ru/smalltalk/gui/">Krasner &amp; Pope</a>).</p>

<ul>
  <li><strong>Модель</strong>: абстрактный суперкласс <strong>Model</strong> реализует общую модель поведения. Он реализует механизм зависимости обслуживания.</li>
</ul>

<p>Вид может зарегистрироваться на конкретную модель чтобы стать подписчиком и получать оповещения об изменениях. Если конкретная модель рассылает свои сообщения, то они будут автоматически отправлены всем своим подписанным представлениям. Это реализация <a href="https://ru.wikipedia.org/wiki/%D0%9D%D0%B0%D0%B1%D0%BB%D1%8E%D0%B4%D0%B0%D1%82%D0%B5%D0%BB%D1%8C_%28%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%29">паттерна Наблюдатель</a> (паттерн поведения объектов). Конкретная модель напрямую не знает о зависимых от него представлениях.</p>

<ul>
  <li><strong>Представление</strong>: абстрактный суперкласс <strong>View</strong> реализует общие поведения представления. Встроенный набор компонентов подкласса представления (например, StandardSystemView — стандартное окно и TextEditorView — текстовый редактор).</li>
</ul>

<p>Представления могут быть вложенными для разработки сложного пользовательского интерфейса. Например, StandardSystemView (т.е. окна) содержит компонент представления, называемые TextEditorView.
Каждое представление может иметь одну модель и один контроллер. Встроенный компоненты по умолчанию имеют заранее определенный класс контроллера для реализации своего стандартного поведения. Чтобы создать экземпляр компонента, вам нужно настроить свою модель и отобразить компонент. Компонент затем будет инициализировать по умолчанию контроллер со своим экземпляром модели и регистрироваться в ней для получения сообщений. При закрытии компонента, освобождаются все вложенные компоненты. Когда представление освободилось, оно удаляет свои подписки на сообщения из модели. Если вы хотите чтобы компоненты имели своё уникальное поведения, вы можете создать свой контроллер для него.</p>

<ul>
  <li><strong>Контроллер</strong>: абстрактный суперкласс <strong>Controller</strong> реализующий общие поведения. Каждый контроллер имеет ссылку на одну модель, один контроллер, и глобальную переменную называемую сенсор, который предоставляет интерфейс взаимодействия для устройств ввода (мышь, клавиатура). Абстрактный класс контроллера реализующий его общие поведения для определения уже конкретного контроллера и соответствующего ему представления. Если конкретное представление является активным (которое в данный момент использует пользователь), то егоконтроллер осуществляет управление всего пользовательского ввода.</li>
</ul>

<p>Контроллер должен иметь прямую ссылку на представление, например для того чтобы знать расположен ли сейчас курсора мыши над конкретным представлением. Важно отметить, что только контроллеры, а не представление, получает информацию о вводе данных (с клавиатуры или мышки).</p>

<hr />

<h3 id="ключевые-особенности-реализации-mvc-на-smalltalk-80">Ключевые особенности реализации MVC на <strong>Smalltalk-80</strong>:</h3>

<ul>
  <li>представления могут быть вложенными;</li>
  <li>каждый встроенный компонент (например <strong>ListBox</strong>) это представление;</li>
  <li>каждый вид имеет соответствующий контроллер;</li>
  <li>контроллер осведомляет своё представление, если оно активно;</li>
  <li>активные контроллер (чье представление в данный момент активно) получает данные которые изменил пользователь при помощи устройств ввода;</li>
  <li>контроллер может обновить представление (компонент) на основе действий пользователя;</li>
  <li>контроллер изменяет модель на действий пользователя;</li>
  <li>представление обновляет себя пир помощи наблюдателя, синхронизированного с моделью.</li>
</ul>

:ET