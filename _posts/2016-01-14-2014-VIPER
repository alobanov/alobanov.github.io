---
layout: post
title: V I P E R
description: Архитектура
categories: article
tags:
  - viper
  - ios
  - objective-c
---

#### пердисловие

Данный материал не претендует на авторство, эта статья является нарзкой переводов статей про архитектуру VIPER из разных источников. Список сипользуемого материала:

* [iOS Architecture Patterns][11]
* [Introduction to VIPER][12]
* [Architecting iOS Apps with VIPER][13]

# Вступление

Давайте определим особенности хорошей архитектуры:

1. Сбалансированное **распределение обязанностей** между сущностями, чтобы у каждой была своя строгая роль.
2. **Использование тестов** с первого момента разработки.
3. **Простота в использовании** с возможностью легко поддреживать написаное.

---

### 1. Распределение обязанностей?

Распределение создает нагрузку на наш мозг, в то время как мы пытаемся понять, как все работают. Если вы думаете: чем больше вы разрабатываете тем лучше ваш мозг адаптируется к пониманию сложных вещей, тогда вы правы. Но это также значит что вы не развиваетеся линейно и очень быстро достигнете потолка. И так самый простой путь победить сложности это разделить ответственность на несколько сущностей по принцыпоу [единой ответственности][2].

### 2. Использование тестов?

Это не вопрос для тех, кто уже почувствовал пользу от юнит тестов, которые **не удалось** использовать после добавления новых функций или в результате рефакторинга. Это значит что тесты **спасут** разработчика от поиска ошибок в рантайме, которые могут произойти, когда приложение уже у пользователя и исправление займет неделю прежде чем достигнет пользователя.

### 3. Простота в использовании

VIPER is our application of Clean Architecture to iOS apps. The word VIPER is a backronym for View, Interactor, Presenter, Entity and Routing.
Решил собрать в одном месте все материалы по VIPER'у, а так же написать пару строк от себя. Как говоится когда рассказываешь другим и сам начинаешь глубже разбираться в материале.

--------------------------------------------------------------------------------

# Теория
Главные части VIPER'а это:<br />

* **View**: displays what it is told to by the Presenter and relays user input back to the Presenter.<br />
* **Interactor**: contains the business logic as specified by a use case.<br />
* **Presenter**: contains view logic for preparing content for display (as received from the Interactor) and for reacting to user inputs (by requesting new data from the Interactor).<br />
* **Entity**: содержит базовую модель объектов которую использует _interactor_.<br />
* **Routing**: содержит описание логики переходов, какие экраны показать и в каком порядке.<br />

Это не введение в модель MVC, а обзор его осуществления на [Smalltalk-80][1] для понимания первоначальных намерений и функций триады. Классическая MVC поможет лучше понять последующее развитие паттернов, которые появились позже. Посмотрим, как простое MVC приложение работает в **Smalltalk-80** и изучим как оно может быть реализовано на языке **ActionScript**.

> **Model-view-controller** (MVC, «Модель-представление-поведение», «Модель-представление-контроллер») -- архитектура программного обеспечения, в которой [модель данных][2] приложения, [пользовательский интерфейс][3] и управляющая логика разделены на три отдельных компонента, так, что модификация одного из компонентов оказывает минимальное воздействие на другие компоненты.

## Реализация Model-View-Controller в Smalltalk-80.
Модель MVC облегчает разделение ответственности при разработке интерактивных графических приложений. Логика и состояние приложения, как пользователи взаимодействуют с приложением, и как состояние приложения представляется пользователю по средствам отдельных элементов триады MVC. **Smalltalk-80** использует метафору MVC, что обеспечивает встроенную поддержку для интерактивной разработки приложений.

Идея заключалась в том, чтобы обеспечить набор встроенных компонентов [пользовательского интерфейса][4], таких как кнопки, меню и списки, которые могут быть подключены к GUI приложения. Для эффективного использования этих встроенных элементов интерфейса, реализация должна была быть построена в соответствии с _MVC_. Давайте посмотрим на концептуальную диаграмму приложения **Smalltalk-80**. <br />

--------------------------------------------------------------------------------

![][image-1]

### :point_up: Диаграмма MVC в Smalltalk-80 (Krasner & Pope)

--------------------------------------------------------------------------------

Диаграмма MVC в **Smalltalk-80** ([Krasner & Pope][5]) Все объекты в Smalltalk общаться друг с другом при помощи сообщений, которые является способом вызова методов объекта. На первый взгляд, диаграмма MVC кажется немного странной. Model-View и Controller-Model имеют зависимости направленные в обе стороны. Вторым интересным аспектом было то, что пользовательский ввод идет непосредственно через контроллер. Это является существенным изменением, как правило мы ожидаем от пользователя взаимодействия с элементами интерфейса в представлении (View), а не в корнтроллере.

В **Smalltalk-80**, все данные с устройства ввода подаются непосредственно в контроллер. Давайте кратко рассмотрим, как MVC поддерживается в **Smalltalk-80**.

--------------------------------------------------------------------------------

# MVC классы в Smalltalk-80.
Есть три абстрактных класса называемые Модель, Вид и Контроллер. Все конкретные реализации модели, вида и контроллера должны иметь подклассы этих абстрактных суперклассов. Давайте взглянем на классы (это сокращенное описание -- см. [Krasner & Pope][6]).
- **Модель**: абстрактный суперкласс **Model** реализует общую модель поведения. Он реализует механизм зависимости обслуживания.

Вид может зарегистрироваться на конкретную модель чтобы стать подписчиком и получать оповещения об изменениях. Если конкретная модель рассылает свои сообщения, то они будут автоматически отправлены всем своим подписанным представлениям. Это реализация [паттерна Наблюдатель][7] (паттерн поведения объектов). Конкретная модель напрямую не знает о зависимых от него представлениях.
- **Представление**: абстрактный суперкласс **View** реализует общие поведения представления. Встроенный набор компонентов подкласса представления (например, StandardSystemView -- стандартное окно и TextEditorView -- текстовый редактор).

Представления могут быть вложенными для разработки сложного пользовательского интерфейса. Например, StandardSystemView (т.е. окна) содержит компонент представления, называемые TextEditorView. Каждое представление может иметь одну модель и один контроллер. Встроенный компоненты по умолчанию имеют заранее определенный класс контроллера для реализации своего стандартного поведения. Чтобы создать экземпляр компонента, вам нужно настроить свою модель и отобразить компонент. Компонент затем будет инициализировать по умолчанию контроллер со своим экземпляром модели и регистрироваться в ней для получения сообщений. При закрытии компонента, освобождаются все вложенные компоненты. Когда представление освободилось, оно удаляет свои подписки на сообщения из модели. Если вы хотите чтобы компоненты имели своё уникальное поведения, вы можете создать свой контроллер для него.
- **Контроллер**: абстрактный суперкласс **Controller** реализующий общие поведения. Каждый контроллер имеет ссылку на одну модель, один контроллер, и глобальную переменную называемую сенсор, который предоставляет интерфейс взаимодействия для устройств ввода (мышь, клавиатура). Абстрактный класс контроллера реализующий его общие поведения для определения уже конкретного контроллера и соответствующего ему представления. Если конкретное представление является активным (которое в данный момент использует пользователь), то егоконтроллер осуществляет управление всего пользовательского ввода.

Контроллер должен иметь прямую ссылку на представление, например для того чтобы знать расположен ли сейчас курсора мыши над конкретным представлением. Важно отметить, что только контроллеры, а не представление, получает информацию о вводе данных (с клавиатуры или мышки).

--------------------------------------------------------------------------------

## Ключевые особенности реализации MVC на **Smalltalk-80**:
- представления могут быть вложенными;
- каждый встроенный компонент (например **ListBox**) это представление;
- каждый вид имеет соответствующий контроллер;
- контроллер осведомляет своё представление, если оно активно;
- активные контроллер (чье представление в данный момент активно) получает данные которые изменил пользователь при помощи устройств ввода;
- контроллер может обновить представление (компонент) на основе действий пользователя;
- контроллер изменяет модель на действий пользователя;
- представление обновляет себя пир помощи наблюдателя, синхронизированного с моделью.

[1]: https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52#.jcq3apf1r
[2]: http://www.wikiwand.com/en/Single_responsibility_principle

[11]: https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52#.9i8drrh43
[12]: http://mutualmobile.github.io/blog/2013/12/04/viper-introduction/
[13]: https://www.objc.io/issues/13-architecture/viper/
[image-1]: /images/schemamvc.jpeg
